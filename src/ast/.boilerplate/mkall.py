#!/usr/bin/env python3
#
# ATTENTION!
# After the parser is established, this should not be used because most of the
# files that are generated by this will have been modified and those changes
# will be lost without any warning or recourse.
#
# Objects created:
#   - C source files
#   - H header files
#   - include file for all of the headers
#   - typedef include file to convert data structures into typedefs
#   - enum header, which lists all of the data types for AST
#   - in a separate file: contains lists that should not be templated into the
#     host file:
#       - list of C files for CMakeLists.txt
#       - %type<> definitions for parser
#       - list of data structures for %union in parser
#
import sys, os, re
from pprint import pprint as pp
import jinja2
import shutil

'''
%token<type> NUMBER NOTHING STRING LIST DICT BOOLEAN PRINT TRACE TYPE
%token<scope> PUBLIC PRIVATE PROTECTED
%token<symbol> SYMBOL
%token<num> NUM
%token<str> STRG
'''
type_table = {
    'NUMBER':'int',
    'NOTHING':'int',
    'STRING':'int',
    'LIST':'int',
    'DICT':'int',
    'BOOLEAN':'int',

    'PUBLIC':'int',
    'PRIVATE':'int',
    'PROTECTED':'int',

    'SYMBOL':'const char*',
    'NUM':'double',
    'STRG':'const char*',
}

#
# Create a list of dependencies for each symbol.
#
def make_depends(fp):

    lst = []
    for line in fp:
        if len(line) > 0:
            tmp = line.strip().split()
            if len(tmp) and tmp[0] == ";":
                break
            else:
                for item in tmp:
                    s = re.search(r"^[A-Za-z_]+$", item)
                    if s:
                        name = s.group(0)
                        if not name in lst:
                            # append unique name
                            lst.append(name)

    return lst

#
# Generate the dictionary of symbols with dependencies
#
def make_symbol_list(infile_name):

    lines = {}

    with open(infile_name, "r") as fp:
        for line in fp:
            line = line.strip()
            if line == "%%":
                for line in fp:
                    s = re.search(r"^[a-z_]+$", line)
                    if s:
                        lines[s.group(0)] = {}
                        lines[s.group(0)]['deps'] = make_depends(fp)
                    if line == "%%":
                        break;

    return lines

def mk_tname(name):
    return ''.join([x.capitalize() for x in name.split('_')])

def emit_typedefs(lst):

    print("emit typedefs header")
    tlst = []
    for item in lst:
        tlst.append("typedef struct _%s_ %s;\n"%(item, mk_tname(item)))

    value = ''.join(tlst)
    with open('ast_typedefs_template.txt', 'r') as fh:
        raw = fh.read()

    templ = jinja2.Template(raw)
    retval = templ.render({'items':value})

    with open(os.path.join('..', 'ast_typedefs.h'), 'w') as fh:
        fh.write(retval)

def emit_includes(lst):

    print("emit includes header")
    tlst = []
    for item in lst:
        tlst.append("#include \"%s.h\"\n"%(item))

    value = ''.join(tlst)
    with open('ast_includes_template.txt', 'r') as fh:
        raw = fh.read()

    templ = jinja2.Template(raw)
    retval = templ.render({'items':value})

    with open(os.path.join('..', 'ast_includes.h'), 'w') as fh:
        fh.write(retval)

def emit_enums(lst):

    print("emit enums header")
    tlst = []
    for item in lst:
        tlst.append("    AST_%s,\n"%(item.upper()))

    value = ''.join(tlst)
    with open('ast_enums_template.txt', 'r') as fh:
        raw = fh.read()

    templ = jinja2.Template(raw)
    retval = templ.render({'items':value})

    with open(os.path.join('..', 'ast_enums.h'), 'w') as fh:
        fh.write(retval)

def emit_header_files(lst):

    print("emit all header files")
    with open('hfile_template.txt', 'r') as fh:
        txt = fh.read()

    templ = jinja2.Template(txt)
    for item in lst:
        fmt = {}
        fmt['filename'] = "%s.h"%(item)
        fmt['lockname'] = item.upper()
        fmt['typename'] = mk_tname(item)
        fmt['strucname'] = "_%s_"%(item)

        tmp1 = []
        tmp2 = []
        for x in lst[item]['deps']:
            if x in type_table or x in lst:
                if x in type_table:
                    tn = type_table[x]
                    tmp1.append("    %s %s;\n"%(tn, x.lower()))
                    tmp2.append("%s"%(tn))
                else:
                    tname = ''.join([t.capitalize() for t in x.split('_')])
                    tmp1.append("    %s* %s;\n"%(tname, x))
                    tmp2.append("%s*"%(tname))
        fmt['strucdef'] = ''.join(tmp1)
        fmt['paradecl'] = ', '.join(tmp2)

        with open(os.path.join('..', "%s.h"%(item)), 'w') as fh:
            fh.write(templ.render(fmt))

traverse_format = '''
        if(ptr->{{iname}} != NULL) {
            AstResult res = {{thing}}{{tname}}(ptr->{{iname}});
            if(res != AST_RES_OK)
                return res;
        }

'''

def mk_traverse(name, item, lst):

    tlst = []
    templ = jinja2.Template(traverse_format)
    for x in lst[item]['deps']:
        if x in lst:
            s = templ.render({'thing':name, 'iname':x, 'tname':mk_tname(x)})
            tlst.append(s)

    if len(tlst) > 0:
        outs = ''.join(tlst)
    else:
        outs = '// nothing to traverse'

    return '// traverse the data structure items'+outs

def emit_source_files(lst):

    print("emit all source files")
    with open('cfile_template.txt', 'r') as fh:
        txt = fh.read()

    templ = jinja2.Template(txt)
    for item in lst:
        fmt = {}
        fmt['typename'] = mk_tname(item)
        fmt['lockname'] = item.upper()
        fmt['filename'] = "%s.c"%(item)
        fmt['pass1'] = mk_traverse("pass1", item, lst)
        fmt['pass2'] = mk_traverse("pass2", item, lst)
        fmt['pass3'] = mk_traverse("pass3", item, lst)
        fmt['emitter'] = mk_traverse("emit", item, lst)
        fmt['destroy'] = mk_traverse("destroy", item, lst)
        fmt['dumper'] = mk_traverse("dump", item, lst)

        tmp1 = [] # inits = 'ptr->%s = %s'
        tmp2 = [] # paras = 'type* type,'
        for x in lst[item]['deps']:
            if x in type_table or x in lst:
                if x in type_table:
                    tn = type_table[x]
                    tmp2.append("%s %s"%(tn, x.lower()))
                else:
                    tname = ''.join([t.capitalize() for t in x.split('_')])
                    tmp2.append("%s* %s"%(tname, x.lower()))
                tmp1.append("    ptr->%s = %s;\n"%(x.lower(), x.lower()))
        fmt['initdefs'] = ''.join(tmp1)
        fmt['paradefs'] = ',\n\t\t'.join(tmp2)

        with open(os.path.join('..', "%s.c"%(item)), 'w') as fh:
            fh.write(templ.render(fmt))


def emit_other_file(lst):

    print("emit other file")
    with open('other_stuff.txt', 'w') as fh:

        fh.write('\n\n')

        fh.write("    /* non-terminal types for %%union{} */\n")
        for item in lst:
            fh.write("    %s* _%s_;\n"%(
                      mk_tname(item),
                      ''.join([x[:3] for x in item.split('_')])))
        fh.write('\n\n')

        fh.write("    /* non-terminal definitions */\n")
        for item in lst:
            fh.write("%%type<_%s_> %s\n"%(
                    ''.join([x[:3] for x in item.split('_')]), item))
        fh.write('\n\n')

        fh.write("    # file names for CMakeLists.txt\n")
        for item in lst:
            fh.write("    %s.c\n"%(item))
        fh.write('\n\n')

if __name__ == '__main__':

    if len(sys.argv) < 2:
        print("need qualified path to parser file")
        exit()
    else:
        infile = os.path.abspath(sys.argv[1])
        print("parsing file: "+ infile)

    symlst = make_symbol_list(infile)

    emit_typedefs(symlst)
    emit_includes(symlst)
    emit_enums(symlst)
    emit_header_files(symlst)
    emit_source_files(symlst)
    emit_other_file(symlst)

    shutil.copy('ast.h', '..')
    shutil.copy('ast.c', '..')
