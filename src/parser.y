%debug
%defines
%locations

%{

#include "ast/ast.h"
#include "import/import.h"

#include "common.h"
#include "scanner.h"
#include "memory.h"
#include "errors.h"

FILE* outfile = NULL;
extern const char* file_name;


%}

%union {
    char* str;
    char* symbol;
    double num;
    int type;
    int scope;

    /* These union objects are generated from boilerplate. */
    /* #include "ast/parser_union.h" */
    /* non-terminal types for %%union{} */
    Module* _mod_;
    ModuleList* _modlis_;
    CompoundName* _comnam_;
    ScopeOperator* _scoope_;
    TypeDefinition* _typdef_;
    ConstantExpression* _conexp_;
    SymbolType* _symtyp_;
    CastSpecifier* _casspe_;
    CompoundNameInParensRule* _comnaminparrul_;
    ArrayReference* _arrref_;
    ExpressionFactor* _expfac_;
    Expression* _exp_;
    ExpressionList* _explis_;
    ExpressionInParensRule* _expinparrul_;
    ExpressionListInParens* _explisinpar_;
    FuncReference* _funref_;
    NamespaceDefinition* _namdef_;
    ClassNameParent* _clanampar_;
    ClassName* _clanam_;
    ClassDefinition* _cladef_;
    ClassDefinitionList* _cladeflis_;
    EmptyParensRule* _empparrul_;
    FuncDeclParameterList* _fundecparlis_;
    ConstructorDecl* _condec_;
    DestructorDecl* _desdec_;
    SymbolDeclaration* _symdec_;
    StructDeclaration* _strdec_;
    StructBody* _strbod_;
    MethodDeclaration* _metdec_;
    ParameterDefList* _pardeflis_;
    ParameterDeclElement* _pardecele_;
    ParameterDeclList* _pardeclis_;
    ArrayInitializer* _arrini_;
    DictInitItem* _diciniite_;
    DictInitElement* _diciniele_;
    DictInitList* _dicinilis_;
    DictInitializer* _dicini_;
    Initialzer* _ini_;
    DataDefinition* _datdef_;
    FuncDefParameterList* _fundefparlis_;
    FuncBodyStatementList* _funbodstalis_;
    FuncBody* _funbod_;
    FuncDefinition* _fundef_;
    BreakStatement* _bresta_;
    ContinueStatement* _consta_;
    YieldStatement* _yiesta_;
    LoopBodyStatement* _loobodsta_;
    LoopBodyStatementList* _loobodstalis_;
    LoopBody* _loobod_;
    ExceptClause* _exccla_;
    ExceptClauseIntermediateList* _excclaintlis_;
    ExceptClauseFinal* _excclafin_;
    ExceptClauseList* _excclalis_;
    TryStatement* _trysta_;
    ElseClause* _elscla_;
    ElseClauseIntermediateList* _elsclaintlis_;
    ElseClauseFinal* _elsclafin_;
    ElseClauseList* _elsclalis_;
    IfClause* _ifcla_;
    IfStatement* _ifsta_;
    ForStatement* _forsta_;
    WhileStatement* _whista_;
    CaseClause* _cascla_;
    CaseClauseIntermediateList* _casclaintlis_;
    CaseClauseList* _casclalis_;
    SwitchStatement* _swista_;
    DoStatement* _dosta_;
    ArrayParameter* _arrpar_;
    ArrayParameterList* _arrparlis_;
    ClassDefinitionItem* _cladefite_;
    ModuleItem* _modite_;
    TraceStatement* _trasta_;
    ReturnStatement* _retsta_;
    PrintStatement* _prista_;
    ExitStatement* _exista_;
    RaiseStatement* _raista_;
    TypeStatement* _typsta_;
    FuncBodyStatement* _funbodsta_;
};

%token BREAK CASE CONTINUE CONST DEFAULT
%token DO ELSE FOR IF RETURN SWITCH IMPORT
%token NAMESPACE CLASS STRUCT WHILE
%token TRUE FALSE IN YIELD EXIT
%token EQU NEQU LORE GORE OR AND
%token TRY EXCEPT RAISE CTOR DTOR

%token<type> NUMBER NOTHING STRING LIST DICT BOOLEAN PRINT TRACE TYPE
%token<scope> PUBLIC PRIVATE PROTECTED
%token<symbol> SYMBOL
%token<num> NUM
%token<str> STRG

    /* token list automatically generated by boilerplate */
    /* #include "ast/parser_types.h" */
    /* non-terminal definitions */
%type<_mod_> module
%type<_modlis_> module_list
%type<_comnam_> compound_name
%type<_scoope_> scope_operator
%type<_typdef_> type_definition
%type<_conexp_> constant_expression
%type<_symtyp_> symbol_type
%type<_casspe_> cast_specifier
%type<_comnaminparrul_> compound_name_in_parens_rule
%type<_arrref_> array_reference
%type<_expfac_> expression_factor
%type<_exp_> expression
%type<_explis_> expression_list
%type<_expinparrul_> expression_in_parens_rule
%type<_explisinpar_> expression_list_in_parens
%type<_funref_> func_reference
%type<_namdef_> namespace_definition
%type<_clanampar_> class_name_parent
%type<_clanam_> class_name
%type<_cladef_> class_definition
%type<_cladeflis_> class_definition_list
%type<_empparrul_> empty_parens_rule
%type<_fundecparlis_> func_decl_parameter_list
%type<_condec_> constructor_decl
%type<_desdec_> destructor_decl
%type<_symdec_> symbol_declaration
%type<_strdec_> struct_declaration
%type<_strbod_> struct_body
%type<_metdec_> method_declaration
%type<_pardeflis_> parameter_def_list
%type<_pardecele_> parameter_decl_element
%type<_pardeclis_> parameter_decl_list
%type<_arrini_> array_initializer
%type<_diciniite_> dict_init_item
%type<_diciniele_> dict_init_element
%type<_dicinilis_> dict_init_list
%type<_dicini_> dict_initializer
%type<_ini_> initialzer
%type<_datdef_> data_definition
%type<_fundefparlis_> func_def_parameter_list
%type<_funbodstalis_> func_body_statement_list
%type<_funbod_> func_body
%type<_fundef_> func_definition
%type<_bresta_> break_statement
%type<_consta_> continue_statement
%type<_yiesta_> yield_statement
%type<_loobodsta_> loop_body_statement
%type<_loobodstalis_> loop_body_statement_list
%type<_loobod_> loop_body
%type<_exccla_> except_clause
%type<_excclaintlis_> except_clause_intermediate_list
%type<_excclafin_> except_clause_final
%type<_excclalis_> except_clause_list
%type<_trysta_> try_statement
%type<_elscla_> else_clause
%type<_elsclaintlis_> else_clause_intermediate_list
%type<_elsclafin_> else_clause_final
%type<_elsclalis_> else_clause_list
%type<_ifcla_> if_clause
%type<_ifsta_> if_statement
%type<_forsta_> for_statement
%type<_whista_> while_statement
%type<_cascla_> case_clause
%type<_casclaintlis_> case_clause_intermediate_list
%type<_casclalis_> case_clause_list
%type<_swista_> switch_statement
%type<_dosta_> do_statement
%type<_arrpar_> array_parameter
%type<_arrparlis_> array_parameter_list
%type<_cladefite_> class_definition_item
%type<_modite_> module_item
%type<_trasta_> trace_statement
%type<_retsta_> return_statement
%type<_prista_> print_statement
%type<_exista_> exit_statement
%type<_raista_> raise_statement
%type<_typsta_> type_statement
%type<_funbodsta_> func_body_statement

%define parse.error verbose
%locations

%right '='
%left CAST
%left OR
%left AND
%left EQU NEQU
%left LORE GORE '<' '>'
%left '+' '-'
%left '*' '/' '%'
%left NEGATE

%%

module
    : module_list {}
    ;

module_list
    : module_item {}
    | module_list module_item {}
    ;

compound_name
    : SYMBOL {}
    | compound_name '.' SYMBOL {}
    ;

scope_operator
    : PRIVATE {}
    | PUBLIC {}
    | PROTECTED {}
    ;

type_definition
    : NUMBER {}
    | STRING {}
    | BOOLEAN {}
    | NOTHING {}
    | LIST {}
    | DICT {}
    | compound_name {}
    ;

constant_expression
    : NUM {}
    | TRUE {}
    | FALSE {}
    | STRG {}
    ;

symbol_type
    : type_definition SYMBOL {}
    ;

cast_specifier
    : type_definition '@' {}
    ;

compound_name_in_parens_rule
    : '(' compound_name ')' {}
    ;

array_reference
    : compound_name array_parameter_list {}
    ;

expression_factor
    : constant_expression {}
    | compound_name {}
    | array_reference {}
    | func_reference {}
    ;

expression
    : expression_factor {}
    | expression '+' expression {}
    | expression '-' expression {}
    | expression '*' expression {}
    | expression '/' expression {}
    | expression '%' expression {}
    | expression EQU expression {}
    | expression NEQU expression {}
    | expression LORE expression {}
    | expression GORE expression {}
    | expression OR expression {}
    | expression AND expression {}
    | expression '<' expression {}
    | expression '>' expression {}
    | '-' expression %prec NEGATE {}
    | '!' expression %prec NEGATE {}
    |  cast_specifier expression %prec CAST {}
    | expression_in_parens_rule {}
    ;

expression_list
    : expression {}
    | expression_list ',' expression {}
    ;

expression_in_parens_rule
    : '(' expression ')' {}
    | empty_parens_rule {}
    ;

expression_list_in_parens
    : '(' expression_list ')' {}
    | empty_parens_rule {}
    ;

func_reference
    : compound_name expression_list_in_parens {}
    ;

namespace_definition
    : NAMESPACE SYMBOL '{' module_list '}' {}
    | NAMESPACE SYMBOL '{' '}' {}
    ;

class_name_parent
    : /* EMPTY */ {}
    | compound_name_in_parens_rule {}
    | empty_parens_rule {}
    ;

class_name
    : CLASS SYMBOL class_name_parent {}
    ;

class_definition
    : class_name'{' class_definition_list '}' {}
    | class_name '{' '}' {}
    ;

class_definition_list
    : class_definition_item {}
    | class_definition_list class_definition_item {}
    ;

empty_parens_rule
    : '(' ')' {}
    ;

func_decl_parameter_list
    : '(' parameter_decl_list ')' {}
    | empty_parens_rule {}
    ;

constructor_decl
    : CTOR func_decl_parameter_list {}
    ;

destructor_decl
    : DTOR {}
    ;

symbol_declaration
    : symbol_type {}
    | CONST symbol_type {}
    ;

struct_declaration
    : STRUCT SYMBOL '{' struct_body '}' {}
    | STRUCT SYMBOL '{' '}' {}
    ;

struct_body
    : symbol_declaration {}
    | struct_body symbol_declaration {}
    ;

method_declaration
    : type_definition SYMBOL func_decl_parameter_list {}
    ;

parameter_def_list
    : symbol_declaration {}
    | parameter_def_list ',' symbol_declaration {}
    ;

parameter_decl_element
    : type_definition {}
    | CONST type_definition {}
    ;

parameter_decl_list
    : parameter_decl_element {}
    | parameter_decl_list ',' parameter_decl_element {}
    ;

array_initializer
    : '[' expression_list ']' {}
    ;

dict_init_item
    : expression {}
    | dict_initializer {}
    | array_initializer {}
    ;

dict_init_element
    : STRG ':' dict_init_item {}
    | compound_name ':' dict_init_item {}
    ;

dict_init_list
    : dict_init_element {}
    | dict_init_list ',' dict_init_element {}
    ;

dict_initializer
    : '[' dict_init_list ']' {}
    ;

initialzer
    : expression {}
    | array_initializer {}
    | dict_initializer {}
    ;

data_definition
    : symbol_declaration {}
    | symbol_declaration '=' initialzer {}
    ;

func_def_parameter_list
    : '(' parameter_def_list ')' {}
    | '(' ')' {}
    ;

func_body_statement_list
    : func_body_statement {}
    | func_body_statement_list func_body_statement {}
    ;

func_body
    : '{' func_body_statement_list '}' {}
    | '{' '}' {}
    ;

func_definition
    : type_definition compound_name func_def_parameter_list func_body {}
    | compound_name '.' CTOR func_def_parameter_list func_body {}
    | compound_name '.' DTOR func_body {}
    ;

break_statement
    : BREAK {}
    ;

continue_statement
    : CONTINUE {}
    ;

yield_statement
    : YIELD {}
    ;

loop_body_statement
    : func_body_statement {}
    | break_statement {}
    | continue_statement {}
    | yield_statement {}
    | error {}
    ;

loop_body_statement_list
    : loop_body_statement {}
    | loop_body_statement_list loop_body_statement {}
    ;

loop_body
    : '{' loop_body_statement_list '}' {}
    | '{' '}' {}
    ;

except_clause
    : EXCEPT compound_name_in_parens_rule func_body {}
    ;

except_clause_intermediate_list
    : except_clause {}
    | except_clause_intermediate_list except_clause {}
    ;

except_clause_final
    : EXCEPT empty_parens_rule func_body {}
    | EXCEPT func_body {}
    ;

except_clause_list
    : except_clause_intermediate_list {}
    | except_clause_intermediate_list except_clause_final {}
    | except_clause_final {}
    ;

try_statement
    : TRY '{' func_body_statement_list '}' except_clause_list {}
    ;

    /* conflicts with else_clause_final when using
       the expression_in_parens_rule */
else_clause
    : ELSE '(' expression ')' {} func_body {}
    ;

else_clause_intermediate_list
    : else_clause {}
    | else_clause_intermediate_list else_clause {}
    ;

else_clause_final
    : ELSE empty_parens_rule func_body {}
    | ELSE func_body {}
    ;

else_clause_list
    : else_clause_intermediate_list {}
    | else_clause_intermediate_list else_clause_final {}
    | else_clause_final {}
    ;

if_clause
    : IF expression_in_parens_rule func_body {}
    ;

if_statement
    : if_clause {}
    | if_clause else_clause_list {}
    ;

for_statement
    : FOR '(' compound_name IN expression ')' loop_body {}
    | FOR empty_parens_rule loop_body {}
    | FOR loop_body {}
    ;

while_statement
    : WHILE expression_in_parens_rule loop_body {}
    | WHILE loop_body {}
    ;

case_clause
    : CASE '(' constant_expression ')' func_body {}
    ;

case_clause_intermediate_list
    : case_clause {}
    | case_clause_intermediate_list case_clause {}
    ;

case_clause_list
    : case_clause_intermediate_list  {}
    | case_clause_intermediate_list DEFAULT func_body  {}
    ;

switch_statement
    : SWITCH compound_name_in_parens_rule '{' case_clause_list '}'  {}
    ;

do_statement
    : DO loop_body WHILE expression_in_parens_rule {}
    | DO loop_body WHILE {}
    ;

    /* This is num for array references. Dict references have a string.
    Other kinds of values are syntax error */
array_parameter
    : '[' expression_factor ']' {}
    | '[' array_parameter ']' {}
    ;

array_parameter_list
    : array_parameter {}
    | array_parameter_list array_parameter {}
    ;

class_definition_item
    : symbol_declaration {}
    | method_declaration {}
    | struct_declaration {}
    | scope_operator {}
    | constructor_decl {}
    | destructor_decl {}
    | error {}
    ;

module_item
    : class_definition {}
    | data_definition {}
    | func_definition {}
    | namespace_definition {}
    | struct_declaration {}
    | scope_operator {}
    | IMPORT STRG { openFile($2); }
    | error {}
    ;

trace_statement
    : TRACE {}
    | TRACE '(' ')' {}
    | TRACE '(' STRG ')' {}
    ;

return_statement
    : RETURN {}
    | RETURN expression_in_parens_rule {}
    ;

print_statement
    : PRINT {}
    | PRINT expression_in_parens_rule {}
    ;

exit_statement
    : EXIT {}
    | EXIT '(' expression ')' {}
    ;

raise_statement
    : RAISE {}
    | RAISE '(' expression ')' {}
    ;

type_statement
    : TYPE '(' expression ')' {}
    ;

func_body_statement
    : data_definition {}
    | compound_name '=' initialzer {}
    | if_statement {}
    | for_statement {}
    | while_statement {}
    | switch_statement {}
    | do_statement {}
    | try_statement {}
    | func_reference {}
    | trace_statement {}
    | return_statement {}
    | print_statement {}
    | exit_statement {}
    | raise_statement {}
    | type_statement {}
    | func_body {}
    ;

%%

void yyerror(const char* s) {

    fprintf(stderr, "%s:%d:%d %s\n", get_file_name(), get_line_no(), get_col_no(), s);
    //error("%s", s);
}

const char* tokenToStr(int tok) {

    return yysymbol_name(YYTRANSLATE(tok));
}
